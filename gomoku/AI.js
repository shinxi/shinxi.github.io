// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

(function() {
  var AIPlayer, BOARD_LENGTH, CHESS_BLACK, CHESS_NONE, CHESS_WHITE, Move, Player, StartUpMove, WIN_COUNT, chessBoard, startTime, timesUp;
  CHESS_NONE = '';
  CHESS_BLACK = '';
  CHESS_WHITE = '';
  BOARD_LENGTH = '';
  WIN_COUNT = 5;
  startTime = 0;
  chessBoard = [];
  timesUp = 1000 * 1000;
  Move = (function() {
    function Move(x1, y1, score1) {
      this.x = x1;
      this.y = y1;
      this.score = score1 != null ? score1 : 0;
    }

    return Move;

  })();
  Player = (function() {
    function Player() {}

    Player.prototype.setName = function(name) {
      this.name = name;
    };

    Player.prototype.toString = function() {
      return "Player: " + this.name;
    };

    return Player;

  })();
  AIPlayer = (function(superClass) {
    var AnalysisResult, addCandidatesAround, alphaBeta, analysis, analysisSinglePoint, bestMove, blackMoves, chessNum, depth, evaluate, genAnalysisResult, genScore, getCandidates, getChessValue, getNextMove, getScore, getSinglePointScore, initMoves, isWin, makeMove, maxX, maxY, minX, minY, myTurn, resetMN, score, skipSpaces, startUpMove, unMakeMove, update, updateMN, updateScore, updateScoreWithBestMove, whiteMoves;

    extend(AIPlayer, superClass);

    depth = 4;

    score = -1;

    minX = 999;

    minY = 999;

    maxX = -1;

    maxY = -1;

    blackMoves = [];

    whiteMoves = [];

    chessNum = 0;

    bestMove = '';

    startUpMove = '';

    myTurn = 1;

    function AIPlayer(gameTurn) {
      var GAME_CONFIG, i, j, k, l, ref, ref1;
      depth = 4;
      score = -1;
      minX = 999;
      minY = 999;
      maxX = -1;
      maxY = -1;
      blackMoves = [];
      whiteMoves = [];
      chessNum = 0;
      bestMove = '';
      startUpMove = '';
      myTurn = 1;
      GAME_CONFIG = window.GAME_CONFIG;
      CHESS_NONE = GAME_CONFIG.CHESS_NONE;
      CHESS_BLACK = GAME_CONFIG.CHESS_BLACK;
      CHESS_WHITE = GAME_CONFIG.CHESS_WHITE;
      BOARD_LENGTH = GAME_CONFIG.BOARD_LENGTH;
      WIN_COUNT = GAME_CONFIG.WIN_COUNT;
      startUpMove = new StartUpMove();
      myTurn = gameTurn;
      for (i = k = 0, ref = BOARD_LENGTH; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        chessBoard[i] = [];
        for (j = l = 0, ref1 = BOARD_LENGTH; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          chessBoard[i][j] = CHESS_NONE;
        }
      }
    }

    AIPlayer.prototype.getMove = function(lastMove) {
      startTime = new Date().getTime();
      if (!lastMove || lastMove.length < 2) {
        myTurn = 0;
      } else {
        update(lastMove[0], lastMove[1], 1 - myTurn);
        chessNum++;
      }
      bestMove = startUpMove.getNextMove(myTurn, chessNum, lastMove);
      if (bestMove) {
        update(bestMove.x, bestMove.y, myTurn);
        chessNum++;
        return [bestMove.x, bestMove.y];
      }
      bestMove = getNextMove(lastMove);
      console.log('getMove takes', (new Date().getTime() - startTime) / 1000);
      chessNum++;
      return [bestMove.x, bestMove.y];
    };

    update = function(x, y, currentTurn) {
      updateMN(x, y);
      chessBoard[x][y] = currentTurn;
    };

    getNextMove = function(lastMove) {
      var ts;
      ts = new Date().getTime();
      score = evaluate();
      console.log('evaluate takes', (new Date().getTime() - ts) / 1000);
      ts = new Date().getTime();
      initMoves();
      console.log('initMoves takes', (new Date().getTime() - ts) / 1000);
      ts = new Date().getTime();
      alphaBeta(depth, -999999999, 999999999, myTurn);
      console.log('alphaBeta takes', (new Date().getTime() - ts) / 1000);
      updateScoreWithBestMove();
      return bestMove;
    };

    updateScoreWithBestMove = function() {
      var x, y;
      x = bestMove.x;
      y = bestMove.y;
      updateMN(x, y);
      chessBoard[x][y] = myTurn;
      score = -1;
    };

    updateMN = function(x, y) {
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    };

    isWin = function(candidate) {
      var aResult, aRs, k, len;
      aRs = genAnalysisResult(candidate.x, candidate.y);
      for (k = 0, len = aRs.length; k < len; k++) {
        aResult = aRs[k];
        if (aResult.count >= WIN_COUNT && aResult.esc === 0) {
          return true;
        }
      }
      return false;
    };

    resetMN = function(t_minX, t_maxX, t_minY, t_maxY) {
      minX = t_minX;
      maxX = t_maxX;
      minY = t_minY;
      maxY = t_maxY;
    };

    makeMove = function(move, currentTurn) {
      update(move.x, move.y, CHESS_NONE);
      updateScore(move.x, move.y, -1);
      if (currentTurn === 1) {
        whiteMoves.push(move);
      } else {
        blackMoves.push(move);
      }
      update(move.x, move.y, currentTurn);
      updateScore(move.x, move.y, 1);
    };

    unMakeMove = function(move) {
      var id;
      if (chessBoard[move.x][move.y] === CHESS_WHITE) {
        id = whiteMoves.indexOf(move);
        if (id > -1) {
          whiteMoves.splice(id, 1);
        }
      } else {
        id = blackMoves.indexOf(move);
        if (id > -1) {
          blackMoves.splice(id, 1);
        }
      }
      chessBoard[move.x][move.y] = CHESS_NONE;
    };

    updateScore = function(x, y, nopSign) {
      var addedScore;
      addedScore = getScore(x, y);
      score += nopSign * addedScore;
    };

    getScore = function(x, y) {
      var addedScore, analysisResult, checkResults, k, len;
      checkResults = genAnalysisResult(x, y);
      addedScore = 0;
      for (k = 0, len = checkResults.length; k < len; k++) {
        analysisResult = checkResults[k];
        addedScore += genScore(analysisResult);
      }
      return addedScore;
    };

    alphaBeta = function(currentDepth, alpha, beta, currentTurn) {
      var candidate, candidates, currentScore, k, lastScore, len, t_maxX, t_maxY, t_minX, t_minY;
      if (currentDepth === 0) {
        return evaluate();
      }
      currentScore = 0;
      candidates = getCandidates();
      if (currentDepth === depth && !bestMove) {
        bestMove = candidates[0];
      }
      for (k = 0, len = candidates.length; k < len; k++) {
        candidate = candidates[k];
        if (candidate.score === 0) {
          continue;
        }
        t_minX = minX;
        t_maxX = maxX;
        t_minY = minY;
        t_maxY = maxY;
        lastScore = score;
        makeMove(candidate, currentTurn);
        if (depth === currentDepth) {
          if (isWin(candidate)) {
            unMakeMove(candidate);
            bestMove = candidate;
            return -1;
          }
          chessBoard[candidate.x][candidate.y] = 1 - currentTurn;
          if (isWin(candidate)) {
            chessBoard[candidate.x][candidate.y] = currentTurn;
            unMakeMove(candidate);
            bestMove = candidate;
            return -1;
          }
          chessBoard[candidate.x][candidate.y] = currentTurn;
        }
        currentScore = -alphaBeta(currentDepth - 1, -beta, -alpha, 1 - currentTurn);
        unMakeMove(candidate);
        score = lastScore;
        resetMN(t_minX, t_maxX, t_minY, t_maxY);
        if (currentScore >= beta) {
          return beta;
        }
        if (currentScore > alpha) {
          alpha = currentScore;
          if (depth === currentDepth) {
            bestMove = candidate;
          }
        }
        if (new Date().getTime() - startTime > timesUp) {
          return alpha;
        }
      }
      return alpha;
    };

    initMoves = function() {
      var chessCell, chessRow, i, j, k, l, len, len1;
      blackMoves = [];
      whiteMoves = [];
      for (i = k = 0, len = chessBoard.length; k < len; i = ++k) {
        chessRow = chessBoard[i];
        for (j = l = 0, len1 = chessRow.length; l < len1; j = ++l) {
          chessCell = chessRow[j];
          if (chessCell === CHESS_BLACK) {
            blackMoves.push(new Move(i, j));
          } else if (chessCell === CHESS_WHITE) {
            whiteMoves.push(new Move(i, j));
          }
        }
      }
    };

    getCandidates = function() {
      var blackMove, candidate, candidates, k, l, len, len1, len2, m, whiteMove;
      candidates = [];
      candidates.cache = {};
      for (k = 0, len = whiteMoves.length; k < len; k++) {
        whiteMove = whiteMoves[k];
        addCandidatesAround(candidates, whiteMove);
      }
      for (l = 0, len1 = blackMoves.length; l < len1; l++) {
        blackMove = blackMoves[l];
        addCandidatesAround(candidates, blackMove);
      }
      for (m = 0, len2 = candidates.length; m < len2; m++) {
        candidate = candidates[m];
        candidate.score = getSinglePointScore(candidate.x, candidate.y);
      }
      candidates.sort(function(candA, candB) {
        return candB.score - candA.score;
      });
      return candidates;
    };

    getSinglePointScore = function(x, y) {
      var addedScore, analysisResult, checkResults, k, len;
      checkResults = [];
      analysisSinglePoint(x, y, 1, 0, 1, 0, checkResults);
      analysisSinglePoint(x, y, 1, 0, 1, 1, checkResults);
      analysisSinglePoint(x, y, 0, 1, 0, 0, checkResults);
      analysisSinglePoint(x, y, 0, 1, 0, 1, checkResults);
      analysisSinglePoint(x, y, 1, 1, 2, 0, checkResults);
      analysisSinglePoint(x, y, 1, 1, 2, 1, checkResults);
      analysisSinglePoint(x, y, -1, 1, 3, 0, checkResults);
      analysisSinglePoint(x, y, -1, 1, 3, 1, checkResults);
      addedScore = 0;
      for (k = 0, len = checkResults.length; k < len; k++) {
        analysisResult = checkResults[k];
        addedScore += Math.abs(genScore(analysisResult));
      }
      return addedScore;
    };

    analysisSinglePoint = function(startX, startY, addX, addY, searchType, type, analysisResults) {
      var count, esc, leftContinueCount, lsc, lsn_x_start, lsn_y_start, needSpacesCount, nextX, nextY, rsc, rsn_x_start, rsn_y_start;
      count = 0;
      esc = 0;
      nextX = startX;
      nextY = startY;
      leftContinueCount = 0;
      chessBoard[startX][startY] = type;
      while (nextX < BOARD_LENGTH && nextY < BOARD_LENGTH && nextX > -1 && nextY > -1) {
        if (getChessValue(nextX, nextY, searchType) === type) {
          count++;
        } else if (esc === 0 && getChessValue(nextX, nextY, searchType) === 2) {
          esc = 1;
          leftContinueCount = count;
        } else {
          break;
        }
        nextX += addX;
        nextY += addY;
      }
      rsc = 0;
      if (getChessValue(nextX, nextY, searchType) === 2) {
        rsc++;
      }
      if (getChessValue(nextX - addX, nextY - addY, searchType) === 2) {
        rsc++;
        esc = 0;
      }
      nextX = startX - addX;
      nextY = startY - addY;
      while (nextX < BOARD_LENGTH && nextY < BOARD_LENGTH && nextX > -1 && nextY > -1) {
        if (getChessValue(nextX, nextY, searchType) === type) {
          count++;
        } else if (esc === 0 && getChessValue(nextX, nextY, searchType) === 2) {
          esc = 1;
          leftContinueCount = count;
        } else {
          break;
        }
        nextX -= addX;
        nextY -= addY;
      }
      lsc = 0;
      if (getChessValue(nextX, nextY, searchType) === 2) {
        lsc++;
      }
      if (getChessValue(nextX + addX, nextY + addY, searchType) === 2) {
        lsc++;
        esc = 0;
      }
      needSpacesCount = WIN_COUNT + 1 - count - rsc - esc - lsc;
      lsn_x_start = startX - addX;
      lsn_y_start = startY - addY;
      if (count + rsc + esc >= WIN_COUNT + 1) {
        if (getChessValue(startX - addX, startY - addY, searchType) === 2) {
          lsc++;
        }
      }
      while (needSpacesCount > 0) {
        if (getChessValue(lsn_x_start, lsn_y_start, searchType) === 2) {
          lsc++;
        } else {
          break;
        }
        lsn_x_start -= addX;
        lsn_y_start -= addY;
        needSpacesCount--;
      }
      if (getChessValue(nextX, nextY, searchType) === 2) {
        rsn_x_start = nextX + addX;
        rsn_y_start = nextY + addY;
        while (needSpacesCount > 0) {
          if (getChessValue(rsn_x_start, rsn_y_start, searchType) === 2) {
            rsc++;
          } else {
            break;
          }
          rsn_x_start += addX;
          rsn_y_start += addY;
          needSpacesCount--;
        }
      }
      if (count + lsc + rsc + esc >= WIN_COUNT) {
        analysisResults.push(new AnalysisResult(count, esc, 0, type, lsc, rsc, searchType, leftContinueCount));
      }
      chessBoard[startX][startY] = CHESS_NONE;
    };

    addCandidatesAround = function(candidates, move) {
      var i, j, k, l, lr_x, lr_y, maxXY, nMove, ref, ref1, ref2, ref3, ul_x, ul_y, x, y;
      x = move.x;
      y = move.y;
      maxXY = BOARD_LENGTH - 1;
      ul_x = x > 0 ? x - 1 : 0;
      ul_y = y > 0 ? y - 1 : 0;
      lr_x = x < maxXY ? x + 1 : maxXY;
      lr_y = y < maxXY ? y + 1 : maxXY;
      for (j = k = ref = ul_y, ref1 = lr_y; ref <= ref1 ? k <= ref1 : k >= ref1; j = ref <= ref1 ? ++k : --k) {
        for (i = l = ref2 = ul_x, ref3 = lr_x; ref2 <= ref3 ? l <= ref3 : l >= ref3; i = ref2 <= ref3 ? ++l : --l) {
          if (chessBoard[i][j] === CHESS_NONE) {
            nMove = new Move(i, j);
            if (!candidates.cache[i + "_" + j]) {
              candidates.push(nMove);
              candidates.cache[i + "_" + j] = true;
            }
          }
        }
      }
    };

    evaluate = function() {
      var analysisResult, analysisResults, k, len;
      if (score !== -1) {
        return score;
      }
      analysisResults = genAnalysisResult();
      for (k = 0, len = analysisResults.length; k < len; k++) {
        analysisResult = analysisResults[k];
        score += genScore(analysisResult);
      }
      return score;
    };

    genScore = function(analysisResult) {
      var count, esc, lScore, leftContinueCount, lsc, nopSign, rightCoutinueCount, rsc, sCount, times, type;
      count = analysisResult.count;
      type = analysisResult.type;
      esc = analysisResult.esc;
      lsc = analysisResult.lsc;
      rsc = analysisResult.rsc;
      leftContinueCount = analysisResult.leftContinueCount;
      times = 1;
      lScore = 0;
      nopSign = 1;
      sCount = WIN_COUNT;
      if (type === 1 - myTurn) {
        nopSign = -1;
      } else {
        times = 1.1;
      }
      if (count === 5) {
        if (myTurn === 1 && type === 0) {
          times = 2;
        }
        if (esc === 0) {
          lScore = 50000;
        } else {
          rightCoutinueCount = count - leftContinueCount;
          if ((rightCoutinueCount === 4 && rsc === 1) || (leftContinueCount === 4 && lsc === 1)) {
            lScore = 4320 + 20;
          } else if ((rightCoutinueCount === 4 && rsc === 0) || (leftContinueCount === 4 && lsc === 0)) {
            lScore = 720 + 20;
          } else if ((rightCoutinueCount === 3 && rsc === 1) || (leftContinueCount === 3 && lsc === 1)) {
            lScore = 720 + 120;
          } else if ((rightCoutinueCount === 3 && rsc === 0) || (leftContinueCount === 3 && lsc === 0)) {
            lScore = 120 + 120;
          } else {
            lScore = 120 + 120;
          }
        }
        return nopSign * lScore * times;
      }
      if (count > 5) {
        if (myTurn === 1 && type === 0) {
          times = 2;
        }
        if (esc === 0) {
          lScore = 500000;
        } else {
          rightCoutinueCount = count - leftContinueCount;
          if (leftContinueCount > 5 || rightCoutinueCount > 5) {
            lScore = 500000;
          } else if (leftContinueCount === 5 || rightCoutinueCount === 5) {
            lScore = 50000;
          } else {
            if ((rightCoutinueCount === 4 && rsc === 1) || (leftContinueCount === 4 && lsc === 1)) {
              if (rightCoutinueCount + leftContinueCount === 8) {
                lScore = 4320 + 4320;
              } else if (rightCoutinueCount + leftContinueCount === 7) {
                lScore = 4320 + 720;
              } else if (rightCoutinueCount + leftContinueCount === 6) {
                lScore = 4320 + 120;
              } else {
                lScore = 4320 + 120;
              }
            } else if ((rightCoutinueCount === 4 && rsc === 0) || (leftContinueCount === 4 && lsc === 0)) {
              if (rightCoutinueCount + leftContinueCount === 8) {
                lScore = 720 + 4320;
              } else if (rightCoutinueCount + leftContinueCount === 7) {
                lScore = 720 + 720;
              } else if (rightCoutinueCount + leftContinueCount === 6) {
                lScore = 720 + 120;
              } else {
                lScore = 720 + 120;
              }
            } else if ((rightCoutinueCount === 3 && rsc === 1) || (leftContinueCount === 3 && lsc === 1)) {
              lScore = 720 + 720;
            } else if ((rightCoutinueCount === 3 && rsc === 0) || (leftContinueCount === 3 && lsc === 0)) {
              lScore = 120 + 120 + 120;
            } else {
              lScore = 120 + 120 + 120;
            }
          }
        }
        return nopSign * lScore * times;
      }
      switch (count) {
        case 1:
          if (myTurn === 1 && type === 0) {
            times = 1.5;
          }
          sCount = WIN_COUNT - 1;
          if (lsc === 0 || rsc === 0) {
            if (lsc > sCount || rsc > sCount) {
              lScore = 10;
            } else {
              lScore = 5;
            }
          } else if (lsc + rsc === sCount) {
            lScore = 5;
          } else if (lsc + rsc > sCount) {
            lScore = 20;
          } else {
            lScore = 5;
          }
          break;
        case 2:
          if (myTurn === 1 && type === 0) {
            times = 1.5;
          }
          sCount = WIN_COUNT - 2;
          if (esc === 0) {
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 120;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > sCount) {
                lScore = 60;
              } else {
                lScore = 20;
              }
            }
          } else if (esc === 1) {
            sCount = WIN_COUNT - 3;
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 120;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > sCount) {
                lScore = 40;
              } else {
                lScore = 20;
              }
            }
          } else {
            lScore = 20;
          }
          break;
        case 3:
          if (myTurn === 1 && type === 0) {
            times = 2;
          }
          sCount = WIN_COUNT - 3;
          if (esc === 0) {
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 840;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > sCount) {
                lScore = 360;
              } else {
                lScore = 120;
              }
            }
          } else if (esc === 1) {
            sCount = WIN_COUNT - 4;
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 720;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > sCount) {
                lScore = 240;
              } else {
                lScore = 120;
              }
            }
          } else {
            lScore = 120;
          }
          break;
        case 4:
          if (myTurn === 1 && type === 0) {
            times = 2;
          }
          sCount = WIN_COUNT - 4;
          if (esc === 0) {
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 5000;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > sCount) {
                lScore = 720;
              } else {
                lScore = 720;
              }
            }
          } else if (esc === 1) {
            if (lsc !== 0 && rsc !== 0 && lsc + rsc > sCount) {
              lScore = 4320;
            } else if (lsc === 0 || rsc === 0) {
              if (lsc + rsc > 0) {
                lScore = 1440;
              } else {

              }
              lScore = 720;
            }
          } else {
            lScore = 720;
          }
      }
      return nopSign * lScore * times;
    };

    genAnalysisResult = function() {
      var checkResults, i, k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      checkResults = [];
      for (i = k = ref = minY, ref1 = maxY + 1; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
        analysis(minX, i, 1, 0, 1, checkResults);
      }
      for (i = l = ref2 = minX, ref3 = maxX + 1; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
        analysis(i, minY, 0, 1, 0, checkResults);
      }
      for (i = m = ref4 = minX, ref5 = maxX + 1; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
        analysis(i, minY, 1, 1, 2, checkResults);
        analysis(i, minY, -1, 1, 3, checkResults);
      }
      for (i = n = ref6 = minY + 1, ref7 = maxY + 1; ref6 <= ref7 ? n < ref7 : n > ref7; i = ref6 <= ref7 ? ++n : --n) {
        analysis(minX, i, 1, 1, 2, checkResults);
        analysis(maxX, i, -1, 1, 3, checkResults);
      }
      return checkResults;
    };

    analysis = function(x, y, addX, addY, searchType, analysisResults) {
      var count, esc, leftContinueCount, lsc, lsn_x_start, lsn_y_start, needSpacesCount, nextX, nextY, rsc, rsn_x_start, rsn_y_start, startXY, type;
      if (!(x < maxX + 1 && y < maxY + 1 && x > minX - 1 && y > minY - 1)) {
        return;
      }
      startXY = skipSpaces(x, y, addX, addY, searchType);
      if (startXY[0] === -1 && startXY[1] === -1) {
        return;
      }
      type = getChessValue(startXY[0], startXY[1], searchType);
      count = 0;
      esc = 0;
      nextX = startXY[0];
      nextY = startXY[1];
      leftContinueCount = 0;
      while (nextX < maxX + 1 && nextY < maxY + 1 && nextX > minX - 1 && nextY > minY - 1) {
        if (getChessValue(nextX, nextY, searchType) === type) {
          count++;
        } else if (esc === 0 && getChessValue(nextX, nextY, searchType) === 2) {
          esc = 1;
          leftContinueCount = count;
        } else {
          break;
        }
        nextX += addX;
        nextY += addY;
      }
      rsc = 0;
      if (getChessValue(nextX, nextY, searchType) === 2) {
        rsc++;
      }
      if (getChessValue(nextX - addX, nextY - addY, searchType) === 2) {
        rsc++;
        esc = 0;
      }
      if (leftContinueCount === 0 && esc === 0) {
        leftContinueCount = count;
      }
      needSpacesCount = WIN_COUNT + 1 - count - rsc - esc;
      lsc = 0;
      lsn_x_start = startXY[0] - addX;
      lsn_y_start = startXY[1] - addY;
      if (count + rsc + esc >= WIN_COUNT + 1) {
        if (getChessValue(startXY[0] - addX, startXY[1] - addY, searchType) === 2) {
          lsc++;
        }
      }
      while (needSpacesCount > 0) {
        if (getChessValue(lsn_x_start, lsn_y_start, searchType) === 2) {
          lsc++;
        } else {
          break;
        }
        lsn_x_start -= addX;
        lsn_y_start -= addY;
        needSpacesCount--;
      }
      if (getChessValue(nextX, nextY, searchType) === 2) {
        rsn_x_start = nextX + addX;
        rsn_y_start = nextY + addY;
        while (needSpacesCount > 0) {
          if (getChessValue(rsn_x_start, rsn_y_start, searchType) === 2) {
            rsc++;
          } else {
            break;
          }
          rsn_x_start += addX;
          rsn_y_start += addY;
          needSpacesCount--;
        }
      }
      if (count + lsc + rsc + esc >= WIN_COUNT) {
        analysisResults.push(new AnalysisResult(count, esc, 0, type, lsc, rsc, searchType, leftContinueCount));
      }
      analysis(nextX, nextY, addX, addY, searchType, analysisResults);
    };

    getChessValue = function(x, y, searchType) {
      if (!(x < BOARD_LENGTH && y < BOARD_LENGTH && x > -1 && y > -1)) {
        return -1;
      }
      return chessBoard[x][y];
    };

    skipSpaces = function(x, y, addX, addY, searchType) {
      var nextX, nextY;
      nextX = x;
      nextY = y;
      while (getChessValue(nextX, nextY, searchType) === 2) {
        nextX += addX;
        nextY += addY;
        if (!(nextX < maxX + 1 && nextY < maxY + 1 && nextX > minX - 1 && nextY > minY - 1)) {
          return [-1, -1];
        }
      }
      return [nextX, nextY];
    };

    AnalysisResult = (function() {
      function AnalysisResult(count1, esc1, isContinueE1, type1, lsc1, rsc1, searchType1, leftContinueCount1) {
        this.count = count1 != null ? count1 : 0;
        this.esc = esc1 != null ? esc1 : 0;
        this.isContinueE = isContinueE1 != null ? isContinueE1 : 0;
        this.type = type1 != null ? type1 : 0;
        this.lsc = lsc1 != null ? lsc1 : 0;
        this.rsc = rsc1 != null ? rsc1 : 0;
        this.searchType = searchType1;
        this.leftContinueCount = leftContinueCount1 != null ? leftContinueCount1 : 0;
      }

      AnalysisResult.prototype.toString = function() {
        return "Type is: " + (type === 0 ? Black : White) + "; SearchType is: " + searchType + "; count is: " + count + "; esc is : " + esc + "; isContinueE: " + isContinueE + "; lsc is: " + lsc + "; rsc is: " + rsc;
      };

      return AnalysisResult;

    })();

    return AIPlayer;

  })(Player);
  window.Player = Player;
  window.AIPlayer = AIPlayer;
  return StartUpMove = (function() {
    var MoveLink, root;

    root = {};

    MoveLink = (function() {
      function MoveLink(currentMove, nextMoves) {
        this.currentMove = currentMove;
        this.nextMoves = nextMoves != null ? nextMoves : [];
      }

      return MoveLink;

    })();

    function StartUpMove() {
      this.init();
    }

    StartUpMove.prototype.init = function() {
      var centerXY, child11, child11_1, child11_10, child11_11, child11_12, child11_13, child11_14, child11_2, child11_3, child11_4, child11_5, child11_6, child11_7, child11_8, child11_9, child11_nextMoves, child12, child12_1, child12_10, child12_11, child12_12, child12_13, child12_2, child12_3, child12_4, child12_5, child12_6, child12_7, child12_8, child12_9, child12_nextMoves, child21, child21_1, child21_10, child21_11, child21_12, child21_2, child21_3, child21_4, child21_5, child21_6, child21_7, child21_8, child21_9, child21_nextMoves, child22, child22_1, child22_10, child22_11, child22_12, child22_13, child22_2, child22_3, child22_4, child22_5, child22_6, child22_7, child22_8, child22_9, child22_nextMoves, root_move, x, y;
      centerXY = Math.floor(BOARD_LENGTH / 2);
      root = new MoveLink(new Move(centerXY, centerXY));
      root_move = root.currentMove;
      x = root_move.x;
      y = root_move.y;
      child11 = new MoveLink();
      child11.currentMove = new Move(x - 1, y + 1);
      child12 = new MoveLink();
      child12.currentMove = new Move(x + 1, y - 1);
      child21 = new MoveLink();
      child21.currentMove = new Move(x, y + 1);
      child22 = new MoveLink();
      child22.currentMove = new Move(x, y - 1);
      root.nextMoves.push(child11);
      root.nextMoves.push(child12);
      root.nextMoves.push(child21);
      root.nextMoves.push(child22);
      child11_nextMoves = child11.nextMoves;
      child11_1 = new MoveLink();
      child11_1.currentMove = new Move(x - 1, y - 1);
      child11_2 = new MoveLink();
      child11_2.currentMove = new Move(x - 2, y);
      child11_3 = new MoveLink();
      child11_3.currentMove = new Move(x - 1, y);
      child11_4 = new MoveLink();
      child11_4.currentMove = new Move(x - 2, y - 1);
      child11_5 = new MoveLink();
      child11_5.currentMove = new Move(x - 2, y + 1);
      child11_6 = new MoveLink();
      child11_6.currentMove = new Move(x + 1, y - 1);
      child11_7 = new MoveLink();
      child11_7.currentMove = new Move(x - 2, y + 2);
      child11_8 = new MoveLink();
      child11_8.currentMove = new Move(x + 2, y);
      child11_9 = new MoveLink();
      child11_9.currentMove = new Move(x - 2, y - 2);
      child11_10 = new MoveLink();
      child11_10.currentMove = new Move(x - 1, y - 2);
      child11_11 = new MoveLink();
      child11_11.currentMove = new Move(x + 1, y);
      child11_12 = new MoveLink();
      child11_12.currentMove = new Move(x + 1, y - 2);
      child11_13 = new MoveLink();
      child11_13.currentMove = new Move(x + 2, y - 2);
      child11_14 = new MoveLink();
      child11_14.currentMove = new Move(x - 2, y + 1);
      child11_nextMoves.push(child11_1);
      child11_nextMoves.push(child11_2);
      child11_nextMoves.push(child11_3);
      child11_nextMoves.push(child11_4);
      child11_nextMoves.push(child11_5);
      child11_nextMoves.push(child11_6);
      child11_nextMoves.push(child11_7);
      child11_nextMoves.push(child11_8);
      child11_nextMoves.push(child11_9);
      child11_nextMoves.push(child11_10);
      child11_nextMoves.push(child11_11);
      child11_nextMoves.push(child11_12);
      child11_nextMoves.push(child11_13);
      child11_nextMoves.push(child11_14);
      child12_nextMoves = child12.nextMoves;
      child12_1 = new MoveLink();
      child12_1.currentMove = new Move(x + 2, y - 2);
      child12_2 = new MoveLink();
      child12_2.currentMove = new Move(x + 2, y - 1);
      child12_3 = new MoveLink();
      child12_3.currentMove = new Move(x + 2, y);
      child12_4 = new MoveLink();
      child12_4.currentMove = new Move(x + 2, y + 1);
      child12_5 = new MoveLink();
      child12_5.currentMove = new Move(x + 2, y + 2);
      child12_6 = new MoveLink();
      child12_6.currentMove = new Move(x + 1, y);
      child12_7 = new MoveLink();
      child12_7.currentMove = new Move(x + 1, y + 1);
      child12_8 = new MoveLink();
      child12_8.currentMove = new Move(x + 1, y + 2);
      child12_9 = new MoveLink();
      child12_9.currentMove = new Move(x, y + 1);
      child12_10 = new MoveLink();
      child12_10.currentMove = new Move(x, y + 2);
      child12_11 = new MoveLink();
      child12_11.currentMove = new Move(x - 1, y + 1);
      child12_12 = new MoveLink();
      child12_12.currentMove = new Move(x - 1, y + 2);
      child12_13 = new MoveLink();
      child12_13.currentMove = new Move(x - 2, y - 2);
      child12_nextMoves.push(child12_1);
      child12_nextMoves.push(child12_2);
      child12_nextMoves.push(child12_3);
      child12_nextMoves.push(child12_4);
      child12_nextMoves.push(child12_5);
      child12_nextMoves.push(child12_6);
      child12_nextMoves.push(child12_7);
      child12_nextMoves.push(child12_8);
      child12_nextMoves.push(child12_9);
      child12_nextMoves.push(child12_10);
      child12_nextMoves.push(child12_11);
      child12_nextMoves.push(child12_12);
      child12_nextMoves.push(child12_13);
      child21_nextMoves = child21.nextMoves;
      child21_1 = new MoveLink();
      child21_1.currentMove = new Move(x + 1, y + 1);
      child21_2 = new MoveLink();
      child21_2.currentMove = new Move(x, y + 2);
      child21_3 = new MoveLink();
      child21_3.currentMove = new Move(x + 1, y);
      child21_4 = new MoveLink();
      child21_4.currentMove = new Move(x + 2, y);
      child21_5 = new MoveLink();
      child21_5.currentMove = new Move(x + 2, y + 1);
      child21_6 = new MoveLink();
      child21_6.currentMove = new Move(x + 2, y - 1);
      child21_7 = new MoveLink();
      child21_7.currentMove = new Move(x + 1, y - 2);
      child21_8 = new MoveLink();
      child21_8.currentMove = new Move(x + 1, y - 1);
      child21_9 = new MoveLink();
      child21_9.currentMove = new Move(x, y - 1);
      child21_10 = new MoveLink();
      child21_10.currentMove = new Move(x, y - 2);
      child21_11 = new MoveLink();
      child21_11.currentMove = new Move(x + 2, y + 2);
      child21_12 = new MoveLink();
      child21_12.currentMove = new Move(x - 2, y - 2);
      child21_nextMoves.push(child21_1);
      child21_nextMoves.push(child21_2);
      child21_nextMoves.push(child21_3);
      child21_nextMoves.push(child21_4);
      child21_nextMoves.push(child21_5);
      child21_nextMoves.push(child21_6);
      child21_nextMoves.push(child21_7);
      child21_nextMoves.push(child21_8);
      child21_nextMoves.push(child21_9);
      child21_nextMoves.push(child21_10);
      child21_nextMoves.push(child21_11);
      child21_nextMoves.push(child21_12);
      child22_nextMoves = child22.nextMoves;
      child22_1 = new MoveLink();
      child22_1.currentMove = new Move(x, y - 2);
      child22_2 = new MoveLink();
      child22_2.currentMove = new Move(x + 1, y - 2);
      child22_3 = new MoveLink();
      child22_3.currentMove = new Move(x + 2, y - 2);
      child22_4 = new MoveLink();
      child22_4.currentMove = new Move(x + 1, y - 1);
      child22_5 = new MoveLink();
      child22_5.currentMove = new Move(x + 2, y - 1);
      child22_6 = new MoveLink();
      child22_6.currentMove = new Move(x + 1, y);
      child22_7 = new MoveLink();
      child22_7.currentMove = new Move(x + 2, y);
      child22_8 = new MoveLink();
      child22_8.currentMove = new Move(x, y + 1);
      child22_9 = new MoveLink();
      child22_9.currentMove = new Move(x + 1, y + 1);
      child22_10 = new MoveLink();
      child22_10.currentMove = new Move(x + 2, y + 1);
      child22_11 = new MoveLink();
      child22_11.currentMove = new Move(x, y + 2);
      child22_12 = new MoveLink();
      child22_12.currentMove = new Move(x + 1, y + 2);
      child22_13 = new MoveLink();
      child22_13.currentMove = new Move(x + 2, y + 2);
      child22_nextMoves.push(child22_1);
      child22_nextMoves.push(child22_2);
      child22_nextMoves.push(child22_3);
      child22_nextMoves.push(child22_4);
      child22_nextMoves.push(child22_5);
      child22_nextMoves.push(child22_6);
      child22_nextMoves.push(child22_7);
      child22_nextMoves.push(child22_8);
      child22_nextMoves.push(child22_9);
      child22_nextMoves.push(child22_10);
      child22_nextMoves.push(child22_11);
      child22_nextMoves.push(child22_12);
      child22_nextMoves.push(child22_13);
    };

    StartUpMove.prototype.getNextMove = function(currentTurn, chessNum, lastMove) {
      var k, lastMoveLink, lastX, lastY, len, moveLink, moveLinks, nextId, nextMoveLink, nmSize, whiteMove;
      if (currentTurn === 0 && chessNum === 0) {
        return root.currentMove;
      }
      if (currentTurn === 0 && chessNum === 2) {
        moveLinks = root.nextMoves;
        lastX = lastMove[0];
        lastY = lastMove[1];
        whiteMove = new Move(lastX, lastY);
        for (k = 0, len = moveLinks.length; k < len; k++) {
          moveLink = moveLinks[k];
          if (moveLink.currentMove.x === whiteMove.x && moveLink.currentMove.y === whiteMove.y) {
            lastMoveLink = moveLink;
            break;
          }
        }
        if (lastMoveLink) {
          nmSize = lastMoveLink.nextMoves.length;
          nextId = Math.floor(Math.random() * nmSize);
          nextMoveLink = lastMoveLink.nextMoves[nextId];
          return nextMoveLink.currentMove;
        }
      }
    };

    return StartUpMove;

  })();
})();
