// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

$(function() {
  var App, AppView, Board, CHESS_BLACK, CHESS_NONE, CHESS_WHITE, GAME_CONFIG, GameEngine, HumanPlayer, HumanPlayerView, S_chessBoardLength, S_xAdd, S_yAdd, chessBoard, chessSize, currentTurn, isDev, isFirstPlayer, paintChess;
  GAME_CONFIG = {
    CHESS_NONE: 2,
    CHESS_BLACK: 0,
    CHESS_WHITE: 1,
    BOARD_LENGTH: 19,
    WIN_COUNT: 5
  };
  window.GAME_CONFIG = GAME_CONFIG;
  S_xAdd = 22;
  S_yAdd = 22;
  chessSize = 36;
  chessBoard = [];
  S_chessBoardLength = GAME_CONFIG.BOARD_LENGTH;
  CHESS_NONE = GAME_CONFIG.CHESS_NONE;
  CHESS_BLACK = GAME_CONFIG.CHESS_BLACK;
  CHESS_WHITE = GAME_CONFIG.CHESS_WHITE;
  currentTurn = 0;
  isFirstPlayer = false;
  isDev = true;
  GameEngine = (function() {
    function GameEngine(board1) {
      this.board = board1;
      if (isFirstPlayer) {
        this.player1 = new HumanPlayer(this, currentTurn);
        this.player1.setName("Player1");
        this.player2 = new window.AIPlayer(1 - currentTurn);
        this.player2.setName("Player2");
      } else {
        this.player1 = new window.AIPlayer(currentTurn);
        this.player1.setName("Player1");
        this.player2 = new HumanPlayer(this, 1 - currentTurn);
        this.player2.setName("Player2");
      }
      this.currentPlayer = this.player1;
      this.currentMove = [];
    }

    GameEngine.prototype.showSuccess = function() {
      $("#winDialog").dialog({
        resizable: false,
        height: 300,
        modal: false,
        buttons: {
          OK: function() {
            $(this).dialog("close");
            $("#playerOrder input:checked").trigger('click');
            $("#btnStart").trigger('click');
          },
          Cancel: function() {
            $(this).dialog("close");
          }
        }
      });
    };

    GameEngine.prototype.showFailure = function() {
      $("#loseDialog").dialog({
        resizable: false,
        height: 300,
        modal: false,
        buttons: {
          OK: function() {
            $(this).dialog("close");
            $("#playerOrder input:checked").trigger('click');
            $("#btnStart").trigger('click');
          },
          Cancel: function() {
            $(this).dialog("close");
          }
        }
      });
    };

    GameEngine.prototype.play = function() {
      var currentPlayer, nextMove, result, st;
      if (result = this.isWin()) {
        console.log(result);
        if ((result[1] === 0 && isFirstPlayer) || (result[1] === 1 && !isFirstPlayer)) {
          this.showSuccess();
        } else if ((result[1] === 0 && !isFirstPlayer) || (result[1] === 1 && isFirstPlayer)) {
          this.showFailure();
        }
        return;
      }
      currentPlayer = this.currentPlayer;
      if (currentPlayer instanceof HumanPlayer) {
        return;
      }
      st = new Date().getTime();
      nextMove = currentPlayer.getMove(this.currentMove);
      console.log(currentPlayer.toString(), 'spent', new Date().getTime() - st);
      this.update(nextMove);
    };

    GameEngine.prototype.update = function(move) {
      var play;
      console.log(this.currentPlayer.toString(), "is making the move");
      this.currentMove = move;
      this.board.update(move);
      if (this.currentPlayer === this.player1) {
        this.currentPlayer = this.player2;
      } else {
        this.currentPlayer = this.player1;
      }
      play = _.bind(this.play, this);
      setTimeout(play, 200);
    };

    GameEngine.prototype.isWin = function() {
      var checkFive, i, isChessAtRange, k, l, m, n, o, ref, ref1, ref2, ref3, ref4, result;
      isChessAtRange = function(x, y) {
        return x > -1 && x < S_chessBoardLength && y > -1 && y < S_chessBoardLength;
      };
      checkFive = function(x, y, addX, addY) {
        var count, type;
        while (chessBoard[x][y] === CHESS_NONE) {
          x += addX;
          y += addY;
          if (!isChessAtRange(x, y)) {
            return;
          }
        }
        type = chessBoard[x][y];
        count = 0;
        while (chessBoard[x][y] === type) {
          count++;
          x += addX;
          y += addY;
          if (count === GAME_CONFIG.WIN_COUNT) {
            return [1, type];
          }
          if (!isChessAtRange(x, y)) {
            return;
          }
        }
        return checkFive(x, y, addX, addY);
      };
      for (i = k = 0, ref = S_chessBoardLength; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        result = checkFive(i, 0, 0, 1);
        if (result) {
          return result;
        }
      }
      for (i = l = 0, ref1 = S_chessBoardLength; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        result = checkFive(0, i, 1, 0);
        if (result) {
          return result;
        }
      }
      for (i = m = 4, ref2 = S_chessBoardLength; 4 <= ref2 ? m < ref2 : m > ref2; i = 4 <= ref2 ? ++m : --m) {
        result = checkFive(i, 0, -1, 1);
        if (result) {
          return result;
        }
      }
      for (i = n = 4, ref3 = S_chessBoardLength; 4 <= ref3 ? n < ref3 : n > ref3; i = 4 <= ref3 ? ++n : --n) {
        result = checkFive(i, 0, -1, 1);
        if (result) {
          return result;
        }
        result = checkFive(S_chessBoardLength - 1 - i, 0, 1, 1);
        if (result) {
          return result;
        }
      }
      for (i = o = 1, ref4 = S_chessBoardLength - 4; 1 <= ref4 ? o < ref4 : o > ref4; i = 1 <= ref4 ? ++o : --o) {
        result = checkFive(S_chessBoardLength - 1, i, -1, 1);
        if (result) {
          return result;
        }
        result = checkFive(0, i, 1, 1);
        if (result) {
          return result;
        }
      }
    };

    return GameEngine;

  })();
  HumanPlayer = (function(superClass) {
    extend(HumanPlayer, superClass);

    function HumanPlayer(gameEngine, myTurn) {
      this.view = new HumanPlayerView(gameEngine, myTurn);
    }

    return HumanPlayer;

  })(window.Player);
  paintChess = function(ctx, x, y) {
    var circleCenterX, circleCenterY, grd, radius;
    radius = chessSize / 2 - 3;
    circleCenterX = S_xAdd + chessSize * x;
    circleCenterY = S_yAdd + chessSize * y;
    ctx.beginPath();
    grd = ctx.createRadialGradient(circleCenterX, circleCenterY, radius / 10, circleCenterX, circleCenterY, radius);
    grd.addColorStop(0, currentTurn === 0 ? "#777" : "#fff");
    grd.addColorStop(1, currentTurn === 0 ? "#222" : "#d3d3d3");
    ctx.fillStyle = grd;
    ctx.arc(circleCenterX, circleCenterY, radius, 0, 2 * Math.PI);
    ctx.fill();
  };
  HumanPlayerView = Backbone.View.extend({
    el: $("#main > #chess"),
    mouseMoveAt: [],
    events: {
      "mousemove": "onMouseMove",
      "click": "onClick"
    },
    initialize: function(gameEngine, myTurn1) {
      var board, ctx;
      this.myTurn = myTurn1;
      board = gameEngine.board;
      ctx = this.el.getContext("2d");
      this.ctx = ctx;
      this.el.width = board.el.width;
      this.el.height = board.el.height;
      this.gameEngine = gameEngine;
    },
    onClick: function(event) {
      var mouseMoveAt;
      if (this.myTurn !== currentTurn || this.mouseMoveAt.length !== 2) {
        return;
      }
      mouseMoveAt = this.mouseMoveAt;
      this.playChessSound();
      this.gameEngine.update(mouseMoveAt);
      this.mouseMoveAt = [];
    },
    onMouseMove: function(event) {
      var $el, offsetX, offsetY, paddingLeft, paddingRight, x, y;
      if (this.myTurn !== currentTurn) {
        return;
      }
      $el = this.$el;
      paddingLeft = parseInt($el.css("padding-left"));
      paddingRight = parseInt($el.css("padding-right"));
      offsetX = event.offsetX - S_xAdd - paddingLeft;
      offsetY = event.offsetY - S_yAdd - paddingRight;
      x = Math.round(offsetX / chessSize);
      y = Math.round(offsetY / chessSize);
      if (x < 0) {
        x = 0;
      }
      if (x >= S_chessBoardLength) {
        x = S_chessBoardLength - 1;
      }
      if (y < 0) {
        y = 0;
      }
      if (y >= S_chessBoardLength) {
        y = S_chessBoardLength - 1;
      }
      if ((this.mouseMoveAt[0] !== x || this.mouseMoveAt[1] !== y) && chessBoard[x][y] === 2) {
        this.mouseMoveAt = [x, y];
        this.clearCanvas(this.ctx);
        paintChess(this.ctx, x, y);
      }
    },
    playChessSound: function() {
      $("#chessPutSound")[0].play();
    },
    clearCanvas: function(ctx) {
      ctx.clearRect(0, 0, this.el.width, this.el.height);
    },
    render: function() {}
  });
  Board = Backbone.View.extend({
    el: $("#main > #board"),
    initialize: function() {
      var ctx;
      ctx = this.el.getContext("2d");
      this.ctx = ctx;
      this.render();
    },
    render: function() {
      var chessBoardHeight, chessBoardHeightUnit, chessBoardLength, chessBoardWidth, chessBoardWidthUnit, ctx, i, j, k, l, ref, ref1, x, xAdd, y, yAdd;
      ctx = this.ctx;
      this.chessNum = 0;
      ctx.clearRect(0, 0, this.el.width, this.el.height);
      S_chessBoardLength = GAME_CONFIG.BOARD_LENGTH;
      chessBoardLength = S_chessBoardLength;
      xAdd = S_xAdd;
      yAdd = S_yAdd;
      chessBoardWidth = chessSize * (chessBoardLength - 1) + xAdd * 2;
      chessBoardHeight = chessSize * (chessBoardLength - 1) + yAdd * 2;
      this.el.width = chessBoardWidth;
      this.el.height = chessBoardHeight;
      chessBoardWidthUnit = (chessBoardWidth - xAdd * 2) / (chessBoardLength - 1);
      chessBoardHeightUnit = (chessBoardHeight - yAdd * 2) / (chessBoardLength - 1);
      ctx.lineWidth = 1;
      while (chessBoardLength-- > 0) {
        x = chessBoardWidthUnit * chessBoardLength + xAdd;
        ctx.moveTo(x, yAdd);
        ctx.lineTo(x, chessBoardHeight - yAdd);
        ctx.stroke();
      }
      chessBoardLength = S_chessBoardLength;
      while (chessBoardLength-- > 0) {
        y = chessBoardHeightUnit * chessBoardLength + yAdd;
        ctx.moveTo(xAdd, y);
        ctx.lineTo(chessBoardWidth - xAdd, y);
        ctx.stroke();
      }
      for (i = k = 0, ref = S_chessBoardLength; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        chessBoard[i] = [];
        for (j = l = 0, ref1 = S_chessBoardLength; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          chessBoard[i][j] = CHESS_NONE;
        }
      }
    },
    update: function(move) {
      var chessContext, circleCenterX, circleCenterY, x, y;
      x = move[0];
      y = move[1];
      chessBoard[x][y] = currentTurn;
      this.chessNum++;
      paintChess(this.ctx, x, y);
      if (isDev) {
        circleCenterX = S_xAdd + chessSize * x;
        circleCenterY = S_yAdd + chessSize * y;
        this.ctx.fillStyle = 'white';
        if (currentTurn === 1) {
          this.ctx.fillStyle = 'black';
        }
        this.ctx.fillText(this.chessNum, circleCenterX - 3, circleCenterY + 3);
      }
      chessContext = $("#main > #chess")[0].getContext("2d");
      chessContext.clearRect(0, 0, this.el.width, this.el.height);
      currentTurn = 1 - currentTurn;
    }
  });
  AppView = Backbone.View.extend({
    el: $("#main"),
    initialize: function() {
      this.render();
    },
    render: function() {
      var gameEngine;
      gameEngine = '';
      $("#boardSetting, #playerOrder").buttonset();
      $("#board_15_15").click(function() {
        GAME_CONFIG.BOARD_LENGTH = 15;
        gameEngine = new GameEngine(new Board());
        console.log("board_15-15 clicked");
      });
      $("#board_19_19").click(function() {
        GAME_CONFIG.BOARD_LENGTH = 19;
        gameEngine = new GameEngine(new Board());
        console.log("board_19_19 clicked");
      });
      $("#firstPlayer").click(function() {
        isFirstPlayer = true;
      });
      $("#secondPlayer").click(function() {
        isFirstPlayer = false;
      });
      $("#chessSetting #buttons button").button();
      $("#btnStart").click(function() {
        currentTurn = 0;
        gameEngine = new GameEngine(new Board());
        gameEngine.play();
        console.log('btnStart');
      });
      $("#btnRestart").click(function() {
        $("#btnStart").trigger('click');
        console.log('btnRestart');
      });
      $("#btnQuit").click(function() {
        console.log('btnQuit');
      });
      new Board();
    }
  });
  return App = new AppView;
});
